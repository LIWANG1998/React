参考：

<https://reacttraining.com/react-router/web/guides/quick-start>

<https://github.com/ReactTraining/react-router>

# 一、前言

[React Router](https://github.com/ReactTraining/react-router) 是一个基于 [React](http://facebook.github.io/react/) 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。react-router 包介绍：

- react-router： React Router 核心库
- react-router-dom： 用于 DOM 绑定的 React Router（网页）*
- react-router-native： 用于 React Native 的 React Router（原生）
- react-router-config： 静态路由配置帮助助手

# 二、API

## 1. \< Router >

Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由：

- [< BrowserRouter >](https://reacttraining.com/react-router/web/api/BrowserRouter)：`/` 斜杠形式显示路由路径；
- [< HashRouter >](https://reacttraining.com/react-router/web/api/HashRouter)：`#` 哈希形式显示路由路径；

## 2. < Route >

[< Route >](https://reacttraining.com/react-router/web/api/Route) 组件主要的作用就是当一个location匹配路由的path时，渲染对应组件。

**\# 常用属性：**

- [path](https://reacttraining.com/react-router/web/api/Route/path-string-string)：匹配路径
- [exact](https://reacttraining.com/react-router/web/api/Route/exact-bool)：精确匹配
- [strict](https://reacttraining.com/react-router/web/api/Route/strict-bool)：如果为true，则带有尾随斜杠的路径将只与带有尾随斜杠的location.pathname匹配。

**\# 渲染内容：**

- [component](https://reacttraining.com/react-router/web/api/Route/component)
- [render](https://reacttraining.com/react-router/web/api/Route/render-func)
- [children](https://reacttraining.com/react-router/web/api/Route/children-func)

## 3. \< Link >

[< Link >](https://reacttraining.com/react-router/web/api/Link) 声明式导航，渲染成 \<a>，组件属性如下：

- to：要跳转的路径或地址；
- replace：是否替换当前历史记录

## 4. \< NavLink >

[< NavLink >](https://reacttraining.com/react-router/web/api/NavLink) 是 \< Link > 的一个特殊版本，当呈现的元素与当前URL匹配时，它将向其添加样式属性。

- activeClassName：元素被选中时的类名，默认值为 active；
- activeStyle：元素被选中时的样式；
- exact：精确匹配；
- strict：为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线；
- isActive：判断链接是否激活的额外逻辑的功能；

## 5. \< Switch >

[< switch >](https://reacttraining.com/react-router/web/api/Switch) 组件用来呈现与位置匹配的第一个子\<Route>或\<Redirect>。这与使用一堆< Route >有什么不同？

< Switch >是唯一的，因为它以独占方式呈现路由。相反，与位置匹配的每个< Route >都会进行包含性渲染。考虑这些路线：

```react
<Route path="/about" component={About}/>
<Route path="/:user" component={User}/>
<Route component={NoMatch}/>
```

如果现在的URL是`/about`，那么`<About>`, `<User>`, 还有`<NoMatch>`都会被渲染，因为它们都与路径(path)匹配。这种设计，允许我们以多种方式将多个`<Route>`组合到我们的应用程序中，例如侧栏(sidebars)，面包屑(breadcrumbs)，bootstrap tabs等等。 然而，偶尔我们只想选择一个`<Route>`来渲染。如果我们现在处于`/about`，我们也不希望匹配`/:user`（或者显示我们的 “404” 页面 ）。以下是使用 Switch 的方法来实现：

```react
<Switch>
  <Route exact path="/" component={Home}/>
  <Route path="/about" component={About}/>
  <Route path="/:user" component={User}/>
  <Route component={NoMatch}/>
</Switch>
```

现在，如果我们处于`/about`，`<Switch>`将开始寻找匹配的`<Route>`。`<Route path="/about"/>` 将被匹配， `<Switch>`将停止寻找匹配并渲染`<About>`。同样，如果我们处于`/michael`，`<User>`将被渲染。

# 三、编程式跳转

- `history.push(url) `：路由跳转
- `hisroty.replace(url)`： 路由跳转不计入历史记录
- `history.go(n) `：根据索引前进或者后退
- `history.goBack()`：后退
- `history.goForward()`： 前进

# 四、安装/引用

**\> 安装**

```shell
# YARN
$ yarn add react-router-dom
# NPM
$ npm install react-router-dom
```

**\> 引入**

```js
import {
  BrowserRouter as Router, 
  Route,
  Link  
} from 'react-router-dom';
```

# 五、基础 *

## 1. 路由配置

路由配置是一组指令，用来告诉 router 如何匹配 URL以及匹配后如何执行代码。我们来通过一个简单的例子解释一下如何编写路由配置。

```react
import React from 'react';
import {
  BrowserRouter as Router,
  NavLink,
  Route
} from "react-router-dom";
import Home from "./pages/home/home";
import About from "./pages/about/about";
import Search from "./pages/search/search";
import Mine from "./pages/mine/mine";
import "./App.css";

function App() {
  return (
    <Router>
      <div className="App">
        {/* 头部 */}
        <header>
          <ul>
            <li><NavLink to="/" exact>Home</NavLink></li>
            <li><NavLink to="/about">About</NavLink></li>
            <li><NavLink to="/search">Search</NavLink></li>
            <li><NavLink to="/Mine">Mine</NavLink></li>
          </ul>
        </header>
        {/* 内容 */}
        <main className="content">
          <Route path="/" exact component={Home}></Route>
          <Route path="/about" component={About}></Route>
          <Route path="/search" component={Search}></Route>
          <Route path="/mine" component={Mine}></Route>
        </main>
        {/* 尾部 */}
        <footer>
          <small>CopyRight 2019. by Li-HONGYAO</small>
        </footer>
      </div>
    </Router>
  );
}

export default App;
```

## 2. 路由嵌套

```react
// mine.js
import React from "react";
import {
    Route,
    Link
} from "react-router-dom";

const A = () => <div>我是子路由 A 页面</div>;
const B = () => <div>我是子路由 B 页面</div>;
const C = () => <div>我是子路由 C 页面</div>;

export default class Mine extends React.Component {
    render() {
        let { match } = this.props;
        console.log(match);
        return (
            <div className="page home">
                {/* 嵌套路由 */}
                <ul className="menu-list">
                    <li><Link to={`${match.url}/a`}>A</Link></li>
                    <li><Link to={`${match.url}/b`}>B</Link></li>
                    <li><Link to={`${match.url}/c`}>C</Link></li>
                </ul>
                {/* 路由配置 */}
                <Route path={`${match.path}/a`} component={A}></Route>
                <Route path={`${match.path}/b`} component={B}></Route>
                <Route path={`${match.path}/c`} component={C}></Route>
            </div>
        )
    }
}
```

## 3. 路由传参

### 3.1. 通过 params

**\> 设置参数**

```react
<Route path="/details/:id" component={Details} />
```

**\> 传递参数**

```react
// => 声明式
<Link to='/details/101'>详情</Link>
// => 编程式
this.props.history.push('/details/101');
```

**\> 获取参数**

```react
this.props.match.params.id
```

### 3.2. 通过 query

前提：必须由其他页面跳过来，参数才会被传递过来

注：不需要配置路由表。路由表中的内容照常：

```react
<Route path='/details' component={Details}></Route>
```

**\> 传递参数**

```react
// => 声明式
<Link to={{pathname:'/details', query:{text:'hello'}}}>详情</Link>
// => 编程式
this.props.history.push({pathname:'/details', query:{text:'hello'}})
```

**\> 获取参数**

```react
this.props.location.query.text
```

### 3.3. 通过 state

 同query差不多，只是属性不一样，而且state传的参数是加密的，query传的参数是公开的。

**\> 传递参数**

```react
// => 声明式
<Link to={{pathname:'/details', state:{text:'hello'}}}>详情</Link>
// => 编程式
this.props.history.push({pathname:'/details', state:{text:'hello'}})
```

**\> 获取参数**

```react
this.props.location.state.text
```

| #      | 声明式                | 编程式                | 读取参数             |
| ------ | --------------------- | --------------------- | -------------------- |
| params | to=pathname/参数      | to=pathname/参数      | props.match.params   |
| query  | to={pathname , query} | to={pathname , query} | props.location.query |
| state  | to={pathname, query}  | to={pathname , query} | props.location.state |

## 4. 重定向

```react
// mine.js
import React from "react";
import {
    Route,
    NavLink,
    Redirect
} from "react-router-dom";

const A = () => <div>我是子路由 A 页面</div>;
const B = () => <div>我是子路由 B 页面</div>;
const C = () => <div>我是子路由 C 页面</div>;

export default class Mine extends React.Component {
    render() {
        let { match } = this.props;
        console.log(match);
        return (
            <div className="page home">
                {/* 嵌套路由 */}
                <ul className="menu-list">
                    <li><NavLink to={`${match.url}/a`}>A</NavLink></li>
                    <li><NavLink to={`${match.url}/b`}>B</NavLink></li>
                    <li><NavLink to={`${match.url}/c`}>C</NavLink></li>
                </ul>
                {/* 路由配置 */}
                {/* 路由重定向 */}
                <Redirect to="/mine/a"></Redirect>
                <Route path={`${match.path}/a`} component={A}></Route>
                <Route path={`${match.path}/b`} component={B}></Route>
                <Route path={`${match.path}/c`} component={C}></Route>
            </div>
        )
    }
}
```

## 5. 统一配置

我们可以通过 `react-router-config` 统一配置静态路由。

首先，你需要安装：

```shell
# YARN
$ yarn add react-router-config
# NPM
$ npm i -S react-router-config
```

然后创建 “/src/router/index.js”，配置如下：

```js
import Home from "../pages/home/home";
import Search from "../pages/search/search";
import About from "../pages/about/about";
import Mine from "../pages/mine/mine";

const routes = [
    {
        path: "/",
        component: Home,
        exact: true
    },
    {
        path: "/search",
        component: Search,
        exact: true
    },
    {
        path: "/about",
        component: About,
        exact: true
    },
    {
        path: "/mine",
        component: Mine,
        exact: true
    }
];

export default routes;
```

最后在 “App.js” 文件中使用：

```react
import React, { Component } from "react";
import {renderRoutes} from "react-router-config";
import {
    BrowserRouter as Router,
    Link
} from "react-router-dom";
import routes from "./router";

class App extends Component {
    render() {
        return (
            <Router>
                {/* 路由导航 */}
                <ul className="menu-list">
                    <li><Link to="/">主页</Link></li>
                    <li><Link to="/search">搜索</Link></li>
                    <li><Link to="/about">关于</Link></li>
                    <li><Link to="/mine">我的</Link></li>
                </ul>
                {/* 路由配置 */}
                {renderRoutes(routes)}
            </Router>
        )
    }
}
export default App;

```



































